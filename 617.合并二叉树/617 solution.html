<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 方法1：前序遍历
        // 时间复杂度 O(min(m,n))  m 和 n 分别是两个二叉树的节点个数
        // 空间复杂度 O(min(m,n))
        /**
         * Definition for a binary tree node.
         * function TreeNode(val) {
         *     this.val = val;
         *     this.left = this.right = null;
         * }
         */
        /**
         * @param {TreeNode} t1
         * @param {TreeNode} t2
         * @return {TreeNode}
         */
        var mergeTrees = function (t1, t2) {
            if (!t1) return t2 //若t1节点为空，那直接返回t2节点，不管t2是否为空
            if (!t2) return t1 //若t2为空，那肯定t1肯定不为空，返回t1节点
            t1.val = t1.val + t2.val //能执行到这里证明t1与t2节点均不为空，那就两值相加，替换t1原来的值
            t1.left = mergeTrees(t1.left, t2.left) //递归遍历两者的左子树
            t1.right = mergeTrees(t1.right, t2.right) ////递归遍历两者的右左子树
            return t1 //t1必然是返回的根节点，为啥？因为都拼到t1树上了啊
        };
    </script>
</body>

</html>