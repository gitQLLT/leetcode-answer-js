<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>

<body>
    <script>
        // 方法1：三指针
        // 时间复杂度 O(n) 空间复杂度 O(1)
        // left:0的最右边界，right:2的最左边界，curr当前下标
        var sortColors = function (nums) {
            let left = 0,
                right = nums.length - 1,
                curr = 0;
            while (curr <= right) {
                if (nums[curr] === 0) {
                    [nums[curr], nums[left]] = [nums[left], nums[curr]];
                    //这里为什么可以自信的直接加1而不检测被调换过来的数字呢？我们可以假设被换过来的数字可能为1，2；但是如果这个数字是2，那么在之前的循环中已经被移动末尾了，所以这个数组只可能是1.
                    left++;
                    curr++;
                    continue;
                }
                if (nums[curr] === 2) {
                    [nums[curr], nums[right]] = [nums[right], nums[curr]];
                    right--;
                    continue;
                }
                if (nums[curr] === 1) {
                    curr++;
                    continue;
                }

            }
            return nums
        };

        // test
        let nums = [2,0,2,1,1,0];
        console.log(sortColors(nums))

        // 待补充 单指针，双指针，
    </script>
</body>

</html>